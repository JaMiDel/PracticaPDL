package Analizador;

import java.util.ArrayList;

import java.util.HashMap;
import java.util.Map;

import Objetos.EntradaAux;
import Objetos.Funcion;
import Objetos.Reader;
import Objetos.Tipo;
import Objetos.Token;
import Objetos.Writter;

/** Comprobar si return = tipo_fun **/
public class AnalizadorSintactico {

	private Map<String, ArrayList<Token>> mapFirst;
	private Map<String, ArrayList<Token>> mapFollow;
	private Token actualToken;
	private Token lastToken;
	private Token lastTokenF;
	private ArrayList<Token> auxList;
	private ArrayList<Token> auxListF;
	private String parse;
	private String tipoF;
	private String args;
	private String n_fun;
	private String file_path;
	private boolean flag_fun;
	private boolean flag_eq;
	private boolean flag_cuerpo;
	private Reader lectura;
	private Funcion funcion;
	private AnalizadorLexico aLex;
	private Writter parseWritter;
	private ErrorControl errControl;
	private char currentChar;
	private String currentString;
	private int currentNumber;
	private TablaSimbolosControl stHandler;
	private EntradaAux entry = new EntradaAux(Tipo.VACIO, 0);
	private String rutaAbsoluta;

	public AnalizadorSintactico(String ruta,String rutaFichero) {
		
		this.rutaAbsoluta = rutaFichero;
		this.stHandler = new TablaSimbolosControl(this.rutaAbsoluta);
		this.file_path = ruta;
		System.out.println(rutaFichero);
		System.out.println(newjava.io.File(".").getCanonicalPath());
		System.out.println(System.getProperty("user.dir"));
		//this.parseWritter = new Writter("C:\\Users\\RAYS\\Documents\\Salidas\\parse.txt");
		this.parseWritter = new Writter(rutaFichero + "\\parse.txt");
		this.parse = "Descendente ";
		this.args = "";
		this.tipoF = "";
		this.flag_fun = false;
		this.flag_eq = false;
		this.flag_eq = false;
		lectura = new Reader(ruta);
		//errControl = new ErrorControl("C:\\Users\\RAYS\\Documents\\Salidas\\errores.txt");
		errControl = new ErrorControl(rutaFichero + "\\errores.txt");
		//Writter escritura = new Writter("C:\\Users\\RAYS\\Documents\\Salidas\\token.txt");
		Writter escritura = new Writter(rutaFichero + "\\token.txt");
		aLex = new AnalizadorLexico(lectura, escritura, stHandler, errControl);
		this.actualToken = aLex.getToken();

		inicializarMaps();
		programa();
		parseWritter.write(parse);

	}

	private void programa() {

		this.stHandler.createTable(this.rutaAbsoluta);
		this.ProcedureZ();
		this.stHandler.removeTable();
	}

	// REALIZADO
	private void ProcedureZ() {
		if (this.getFirst("P").contains(this.actualToken)) {
			parse += " 1";
			this.ProcedureP();
		} else if (this.actualToken.equals(Token.EOL)) {
			parse += " 2";
			this.compToken(Token.EOL);
			this.ProcedureZ();
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Estructura de programa o EOL incorrecta",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureP() {
		if (this.getFirst("B").contains(this.actualToken)) {
			parse += " 3";
			this.ProcedureB();
			this.compToken(Token.EOL);
			this.ProcedureZ();
		} else if (this.getFirst("F").contains(this.actualToken)) {
			parse += " 4";
			this.ProcedureF();
			this.compToken(Token.EOL);
			this.ProcedureZ();
		} else if (this.actualToken.equals(Token.EOF)) {
			parse += " 5";
			this.compToken(Token.EOF);
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Codigo, funcion o EOF incorrecto",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureB() {
		if (this.actualToken.equals(Token.VAR)) {
			parse += " 6";
			this.compToken(Token.VAR);
			this.ProcedureT();
			this.compToken(Token.ID);
			if (this.stHandler.buscarTipoTS((Integer) this.lastToken.getAttribute()).equals(Tipo.UNDEFINED)) {
				this.stHandler.insertarTipoTS((Integer) this.lastToken.getAttribute(), entry.tipo, entry.tam);
			} else {
				this.errControl.write(String.format("Linea %d: Analizador Semantico - Variable ' %s ' ya declarada",
						aLex.getFileReader().getCurrentLine() - 1,
						this.stHandler.buscarEntradaPorID((Integer) this.lastToken.getAttribute()).getLexema()));
			}
			this.ProcedureD();
		} else if (this.actualToken.equals(Token.WHILE)) {
			parse += " 7";
			this.compToken(Token.WHILE);
			this.compToken(Token.PARENTESIS_I);
			this.ProcedureR();
			this.compToken(Token.PARENTESIS_D);
			this.compToken(Token.EOL);
			this.ProcedureI();
		} else if (this.getFirst("S").contains(this.actualToken)) {
			parse += " 8";
			this.ProcedureS();
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Declaracion incorrecta",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureI() {
		if (this.getFirst("S").contains(this.actualToken)) {
			parse += " 9";
			this.ProcedureS();
		} else if (this.actualToken.equals(Token.LLAVE_I)) {
			parse += " 10";
			this.compToken(Token.LLAVE_I);
			this.compToken(Token.EOL);
			this.Procedure1();
			this.compToken(Token.LLAVE_D);
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Error en declaracion WHILE",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void Procedure1() {
		if (this.getFirst("B").contains(this.actualToken)) {
			parse += " 11";
			this.ProcedureB();
			this.compToken(Token.EOL);
			this.Procedure2();
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Sentencia incorrecta",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void Procedure2() {
		if (this.getFirst("1").contains(this.actualToken)) {
			parse += " 12";
			this.Procedure1();
		} else if (this.getFollow("2").contains(this.actualToken)) {
			parse += " 13";
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Sentencia incorrecta",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureD() {
		if (this.actualToken.equals(Token.COMA)) {
			parse += " 14";
			this.compToken(Token.COMA);
			this.compToken(Token.ID);
			if (this.stHandler.buscarTipoTS((Integer) this.lastToken.getAttribute()).equals(Tipo.UNDEFINED)) {
				this.stHandler.insertarTipoTS((Integer) this.lastToken.getAttribute(), entry.tipo, entry.tam);
			} else {
				this.errControl.write(String.format("Linea %d: Analizador Semantico - Variable ' %s ' ya declarada",
						aLex.getFileReader().getCurrentLine() - 1,
						this.stHandler.buscarEntradaPorID((Integer) this.lastToken.getAttribute()).getLexema()));
			}
			this.ProcedureD();
		} else if (this.actualToken.equals(Token.ASIGNACION)) {
			parse += " 15";
			this.compToken(Token.ASIGNACION);
			this.ProcedureR();
			this.Procedure3();
		} else if (this.getFollow("D").contains(this.actualToken)) {
			parse += " 16";
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Declaracion incorrecta",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void Procedure3() {
		if (this.actualToken.equals(Token.COMA)) {
			parse += " 17";
			this.compToken(Token.COMA);
			this.compToken(Token.ID);
			if (this.stHandler.buscarTipoTS((Integer) this.lastToken.getAttribute()).equals(Tipo.UNDEFINED)) {
				this.stHandler.insertarTipoTS((Integer) this.lastToken.getAttribute(), entry.tipo, entry.tam);
			} else {
				this.errControl.write(String.format("Linea %d: Analizador Semantico - Variable ' %s ' ya declarada",
						aLex.getFileReader().getCurrentLine() - 1,
						this.stHandler.buscarEntradaPorID((Integer) this.lastToken.getAttribute()).getLexema()));
			}
			this.ProcedureD();
		} else if (this.getFollow("3").contains(this.actualToken)) {
			parse += " 18";
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Declaracion incorrecta",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureS() {
		if (this.actualToken.equals(Token.ID)) {
			parse += " 19";
			this.compToken(Token.ID);
			lastTokenF = this.lastToken;
			this.ProcedureM();
			if (flag_eq) {
				if (!this.stHandler.buscarTipoTS((Integer) lastTokenF.getAttribute()).equals(entry.tipo)) {
					this.errControl.write(String.format("Linea %d: Analizador Semantico - Error en asignacion",
							aLex.getFileReader().getCurrentLine()-1));
					
				}
			}flag_eq = false;
		} else if (this.actualToken.equals(Token.RETURN)) {
			parse += " 20";
			this.compToken(Token.RETURN);
			if(flag_cuerpo){
				this.ProcedureX();
				if(!entry.tipo.equals(tipoF) && !tipoF.equals(Tipo.VACIO)){
					this.errControl.write(String.format("Linea %d: Analizador Semantico - El valor a devolver no es el esperado",
							aLex.getFileReader().getCurrentLine()-1));
				}
			}
			else{
				this.errControl.write(String.format("Linea %d: Analizador Semantico - Uso incorrecto de 'return'",
						aLex.getFileReader().getCurrentLine()));
			}
		} else if (this.actualToken.equals(Token.WRITE)) {
			parse += " 21";
			this.compToken(Token.WRITE);
			this.compToken(Token.PARENTESIS_I);
			flag_fun = true;
			this.ProcedureR();
			flag_fun = false;
			this.compToken(Token.PARENTESIS_D);
		} else if (this.actualToken.equals(Token.PROMPT)) {
			parse += " 22";
			this.compToken(Token.PROMPT);
			this.compToken(Token.PARENTESIS_I);
			this.compToken(Token.ID);
			this.compToken(Token.PARENTESIS_D);
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Sentencia incorrecta",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureM() {
		if (this.actualToken.equals(Token.ASIGNACION)) {
			parse += " 23";
			this.compToken(Token.ASIGNACION);
			this.ProcedureR();
		} else if (this.actualToken.equals(Token.MAYOR)) {
			parse += " 24";
			this.compToken(Token.MAYOR);
			if(entry.tipo.equals(Tipo.INT)){
				this.compToken(Token.MAYOR);
				this.ProcedureR();
				if(!entry.tipo.equals(Tipo.INT)){
					this.errControl.write(String.format("Linea %d: Analizador Sematico - Uso incorrecto de MAYOR '>'",
							aLex.getFileReader().getCurrentLine()));
				}
			}
			entry.tipo=Tipo.BOOL;
		} else if (this.actualToken.equals(Token.PARENTESIS_I)) {
			parse += " 25";
			this.compToken(Token.PARENTESIS_I);
			this.ProcedureL();
			this.compToken(Token.PARENTESIS_D);
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Sentencia incorrecta",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureT() {
		if (this.actualToken.equals(Token.INT)) {
			parse += " 26";
			this.compToken(Token.INT);
			entry.tam = 2;
			entry.tipo = "INT";
		} else if (this.actualToken.equals(Token.BOOL)) {
			parse += " 27";
			this.compToken(Token.BOOL);
			entry.tam = 1;
			entry.tipo = "BOOL";
		} else if (this.actualToken.equals(Token.CHARS)) {
			parse += " 28";
			this.compToken(Token.CHARS);
			entry.tam = 8;
			entry.tipo = "CHARS";
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Tipo de dato incorrecto",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureX() {
		if (this.getFirst("R").contains(this.actualToken)) {
			parse += " 29";
			this.ProcedureR();
		} else if (this.getFollow("X").contains(this.actualToken)) {
			parse += " 30";
		} else {
			this.errControl
					.write(String.format("Linea %d: Analizador Sintactico - Expresion incorrecta",
							aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureR() {
		if (this.getFirst("V").contains(this.actualToken)) {
			parse += " 31";
			this.ProcedureV();
			this.ProcedureN();
		} else {
			this.errControl
					.write(String.format("Linea %d: Analizador Sintactico - Expresion incorrecta",
							aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureN() {
		if (this.actualToken.equals(Token.OR)) {
			parse += " 32";
			this.compToken(Token.OR);
			this.ProcedureV();
			this.ProcedureN();
		} else if (this.getFollow("N").contains(this.actualToken)) {
			parse += " 33";

		} else {
			this.errControl.write(String.format("Linea %d:  Analizador Semantico - Expresion incorrecta",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureV() {
		if (this.getFirst("U").contains(this.actualToken)) {
			parse += " 34";
			this.ProcedureU();
			this.ProcedureO();
		} else {
			this.errControl
					.write(String.format("Linea %d: Analizador Sintactico - Expresion incorrecta",
							aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureO() {
		if (this.actualToken.equals(Token.ASIGNACIONRESTO)) {
			parse += " 35";
			String tipo_aux=entry.tipo;
			this.compToken(Token.ASIGNACIONRESTO);
			this.ProcedureU();
			if(!entry.tipo.equals(tipo_aux)){
				this.errControl.write(String.format("Linea %d: Analizador Semantico - Uso incorrecto del operador ASIGNACION LOGICO '|='",
						aLex.getFileReader().getCurrentLine()));
			}
		} else if (this.getFollow("O").contains(this.actualToken)) {
			parse += " 36";
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Expresion incorrecta",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureU() {
		if (this.getFirst("E").contains(this.actualToken)) {
			parse += " 37";
			this.ProcedureE();
			this.ProcedureW();
		} else {
			this.errControl
					.write(String.format("Linea %d: Analizador Sintactico - Expresion incorrecta",
							aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureW() {
		if (this.actualToken.equals(Token.RESTO)) {
			parse += " 38";
			if(entry.tipo.equals(Tipo.INT)){
				this.compToken(Token.RESTO);
				this.ProcedureU();
				if(!entry.tipo.equals(Tipo.INT)){
					this.errControl.write(String.format("Linea %d: Analizador Semantico - El resto tiene que ser entre enteros",
							aLex.getFileReader().getCurrentLine()));
				}
			}
		} else if (this.getFollow("W").contains(this.actualToken)) {
			parse += " 39";
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Expresion incorrecta",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureE() {
		if (this.actualToken.equals(Token.ID)) {
			parse += " 40";
			this.compToken(Token.ID);
			this.ProcedureY();
		} else if (this.actualToken.equals(Token.PARENTESIS_I)) {
			parse += " 41";
			this.compToken(Token.PARENTESIS_I);
			this.ProcedureR();
			this.compToken(Token.PARENTESIS_D);
		} else if (this.actualToken.equals(Token.NUM)) {
			parse += " 42";
			this.compToken(Token.NUM);
			if (args == "") {
				args = Tipo.INT;
			} else {
				args = args + "," + Tipo.INT;
			}
			entry.tipo = Tipo.INT;
		} else if (this.actualToken.equals(Token.CAD)) {
			parse += " 43";
			this.compToken(Token.CAD);
			if (args == "") {
				args = Tipo.CHARS;
			} else {
				args = args + "," + Tipo.CHARS;
			}
			entry.tipo = Tipo.CHARS;
		} else if (this.actualToken.equals(Token.TRUE)) {
			parse += " 44";
			this.compToken(Token.TRUE);
			entry.tipo = Tipo.BOOL;
		} else if (this.actualToken.equals(Token.FALSE)) {
			parse += " 45";
			this.compToken(Token.FALSE);
			entry.tipo = Tipo.BOOL;
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Expresion incorrecta",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureY() {
		if (this.actualToken.equals(Token.PARENTESIS_I)) {
			parse += " 46";
			this.compToken(Token.PARENTESIS_I);
			this.ProcedureL();
			this.compToken(Token.PARENTESIS_D);
		} else if (this.getFollow("Y").contains(this.actualToken)) {
			parse += " 47";
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Llamada a funcion incorrecta",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureL() {
		if (this.getFirst("R").contains(this.actualToken)) {
			parse += " 48";
			this.ProcedureR();
			this.ProcedureQ();
		} else if (this.getFollow("L").contains(this.actualToken)) {
			parse += " 49";
		} else {
			this.errControl
					.write(String.format("Linea %d: Analizador Sintactico - Expresion incorrecta",
							aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureQ() {
		if (this.actualToken.equals(Token.COMA)) {
			parse += " 50";
			this.compToken(Token.COMA);
			this.ProcedureR();
			this.ProcedureQ();
		} else if (this.getFollow("Q").contains(this.actualToken)) {
			parse += " 51";
		} else {
			this.errControl
					.write(String.format("Linea %d: Analizador Sintactico - Expresion incorrecta",
							aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureF() {
		if (this.actualToken.equals(Token.FUNCTION)) {
			this.auxListF = new ArrayList<>();
			parse += " 52";
			this.compToken(Token.FUNCTION);
			this.ProcedureH();
			this.compToken(Token.ID);
			lastTokenF = this.lastToken;
			this.stHandler.createTable(this.rutaAbsoluta);
			this.compToken(Token.PARENTESIS_I);
			this.ProcedureA();
			this.compToken(Token.PARENTESIS_D);
			this.stHandler.insertarTipoTS((Integer) lastTokenF.getAttribute(), new Funcion(this.args, this.tipoF),
					null);
			args = "";
			this.compToken(Token.EOL);
			this.ProcedureG();
			this.compToken(Token.LLAVE_I);
			flag_cuerpo=true;
			this.compToken(Token.EOL);
			this.ProcedureC();
			flag_cuerpo=false;
			this.compToken(Token.LLAVE_D);
			this.stHandler.removeTable();
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Declaracion de funcion incorrecta",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureG() {
		if (this.actualToken.equals(Token.EOL)) {
			parse += " 53";
			this.compToken(Token.EOL);
			this.ProcedureG();
		} else if (this.getFollow("G").contains(this.actualToken)) {
			parse += " 54";
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Salto de linea incorrecto",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureH() {
		if (this.getFirst("T").contains(this.actualToken)) {
			parse += " 55";
			this.ProcedureT();
			this.tipoF = entry.tipo;
		} else if (this.getFollow("H").contains(this.actualToken)) {
			parse += " 56";
			this.tipoF = Tipo.VACIO;
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Dator devuelto por funcion incorrecto",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureA() {
		if (this.getFirst("T").contains(this.actualToken)) {
			parse += " 57";
			this.ProcedureT();
			this.compToken(Token.ID);
			this.stHandler.insertarTipoTS((Integer) this.lastToken.getAttribute(), entry.tipo, entry.tam);
			this.args = entry.tipo;
			this.ProcedureK();
		} else if (this.getFollow("A").contains(this.actualToken)) {
			parse += " 58";
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Parametro de funcion incorrecto",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureK() {
		if (this.actualToken.equals(Token.COMA)) {
			parse += " 59";
			this.compToken(Token.COMA);
			this.ProcedureT();
			this.compToken(Token.ID);
			this.stHandler.insertarTipoTS((Integer) this.lastToken.getAttribute(), entry.tipo, entry.tam);
			this.args = args + "," + entry.tipo;
			this.ProcedureK();
		} else if (this.getFollow("K").contains(this.actualToken)) {
			parse += " 60";
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Parametro de funcion incorrecto",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureC() {
		if (this.getFirst("B").contains(this.actualToken)) {
			parse += " 61";
			this.ProcedureB();
			this.compToken(Token.EOL);
			this.ProcedureG();
			this.ProcedureJ();
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Codigo en funcion incorrecto",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureJ() {
		if (this.getFirst("C").contains(this.actualToken)) {
			parse += " 62";
			this.ProcedureC();
		} else if (this.getFollow("J").contains(this.actualToken)) {
			parse += " 63";
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Codigo en funcion incorrecto",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	private void compToken(Token token) {
		if (this.actualToken.equals(Token.EOF)) {
			
		} else {
		if (token.equals(Token.EOL)) {
			while (!this.actualToken.equals(Token.EOL) && !this.actualToken.equals(Token.EOF)) {
				this.nextToken();
			}
		}
		if (this.actualToken.equals(token)) {
			if (actualToken.equals(Token.ID) || actualToken.equals(Token.NUM)) {
				this.lastToken = this.actualToken;

			}
			this.nextToken();
		} else if(this.actualToken.equals(Token.EOF)) {
			
		}

		else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico, Error token no esperado",
					aLex.getFileReader().getCurrentLine()));
			nextToken();
			compToken(actualToken);
		}}
	}

	private void nextToken() {
		this.actualToken = this.aLex.getToken();
		if (this.actualToken == null) {
			this.nextToken();
		}
	}

	private ArrayList<Token> getFirst(String a) {
		ArrayList<Token> list = new ArrayList<Token>();
		list = this.mapFirst.get(a);
		return list;
	}

	private ArrayList<Token> getFollow(String a) {
		ArrayList<Token> list = new ArrayList<Token>();
		list = this.mapFollow.get(a);
		return list;
	}

	// INICIALIZA MAPS
	private void inicializarMaps() {
		this.mapFirst = new HashMap<String, ArrayList<Token>>();

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.VAR);
		this.auxList.add(Token.WHILE);
		this.auxList.add(Token.ID);
		this.auxList.add(Token.RETURN);
		this.auxList.add(Token.WRITE);
		this.auxList.add(Token.PROMPT);
		this.auxList.add(Token.EOL);
		this.auxList.add(Token.FUNCTION);
		this.auxList.add(Token.EOF);
		this.mapFirst.put("Z", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.VAR);
		this.auxList.add(Token.WHILE);
		this.auxList.add(Token.ID);
		this.auxList.add(Token.RETURN);
		this.auxList.add(Token.WRITE);
		this.auxList.add(Token.PROMPT);
		this.auxList.add(Token.FUNCTION);
		this.auxList.add(Token.EOF);
		this.mapFirst.put("P", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.VAR);
		this.auxList.add(Token.WHILE);
		this.auxList.add(Token.ID);
		this.auxList.add(Token.RETURN);
		this.auxList.add(Token.WRITE);
		this.auxList.add(Token.PROMPT);
		this.mapFirst.put("B", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.ID);
		this.auxList.add(Token.RETURN);
		this.auxList.add(Token.WRITE);
		this.auxList.add(Token.PROMPT);
		this.auxList.add(Token.LLAVE_I);
		this.mapFirst.put("I", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.VAR);
		this.auxList.add(Token.WHILE);
		this.auxList.add(Token.ID);
		this.auxList.add(Token.RETURN);
		this.auxList.add(Token.WRITE);
		this.auxList.add(Token.PROMPT);
		this.mapFirst.put("1", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.VAR);
		this.auxList.add(Token.WHILE);
		this.auxList.add(Token.ID);
		this.auxList.add(Token.RETURN);
		this.auxList.add(Token.WRITE);
		this.auxList.add(Token.PROMPT);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("2", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.COMA);
		this.auxList.add(Token.ASIGNACION);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("D", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.COMA);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("3", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.ID);
		this.auxList.add(Token.RETURN);
		this.auxList.add(Token.WRITE);
		this.auxList.add(Token.PROMPT);
		this.mapFirst.put("S", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.ASIGNACION);
		this.auxList.add(Token.MAYOR);
		this.auxList.add(Token.PARENTESIS_I);
		this.mapFirst.put("M", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.INT);
		this.auxList.add(Token.BOOL);
		this.auxList.add(Token.CHARS);
		this.mapFirst.put("T", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.ID);
		this.auxList.add(Token.PARENTESIS_I);
		this.auxList.add(Token.NUM);
		this.auxList.add(Token.CAD);
		this.auxList.add(Token.TRUE);
		this.auxList.add(Token.FALSE);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("X", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.ID);
		this.auxList.add(Token.PARENTESIS_I);
		this.auxList.add(Token.NUM);
		this.auxList.add(Token.CAD);
		this.auxList.add(Token.TRUE);
		this.auxList.add(Token.FALSE);
		this.mapFirst.put("R", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.OR);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("N", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.ID);
		this.auxList.add(Token.PARENTESIS_I);
		this.auxList.add(Token.NUM);
		this.auxList.add(Token.CAD);
		this.auxList.add(Token.TRUE);
		this.auxList.add(Token.FALSE);
		this.mapFirst.put("V", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.ASIGNACIONRESTO);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("O", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.ID);
		this.auxList.add(Token.PARENTESIS_I);
		this.auxList.add(Token.NUM);
		this.auxList.add(Token.CAD);
		this.auxList.add(Token.TRUE);
		this.auxList.add(Token.FALSE);
		this.mapFirst.put("U", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.RESTO);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("W", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.ID);
		this.auxList.add(Token.PARENTESIS_I);
		this.auxList.add(Token.NUM);
		this.auxList.add(Token.CAD);
		this.auxList.add(Token.TRUE);
		this.auxList.add(Token.FALSE);
		this.mapFirst.put("E", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.PARENTESIS_I);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("Y", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.ID);
		this.auxList.add(Token.PARENTESIS_I);
		this.auxList.add(Token.NUM);
		this.auxList.add(Token.CAD);
		this.auxList.add(Token.TRUE);
		this.auxList.add(Token.FALSE);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("L", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.COMA);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("Q", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.FUNCTION);
		this.mapFirst.put("F", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.EOL);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("G", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.INT);
		this.auxList.add(Token.BOOL);
		this.auxList.add(Token.CHARS);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("H", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.INT);
		this.auxList.add(Token.BOOL);
		this.auxList.add(Token.CHARS);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("A", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.COMA);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("K", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.VAR);
		this.auxList.add(Token.WHILE);
		this.auxList.add(Token.ID);
		this.auxList.add(Token.RETURN);
		this.auxList.add(Token.WRITE);
		this.auxList.add(Token.PROMPT);
		this.mapFirst.put("C", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.VAR);
		this.auxList.add(Token.WHILE);
		this.auxList.add(Token.ID);
		this.auxList.add(Token.RETURN);
		this.auxList.add(Token.WRITE);
		this.auxList.add(Token.PROMPT);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("J", auxList);

		
		// FOLLOWS
		this.mapFollow = new HashMap<String, ArrayList<Token>>();

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.NULL);
		this.mapFollow.put("Z", auxList);
		
		this.auxList = new ArrayList<>();
		this.auxList.add(Token.NULL);
		this.mapFollow.put("P", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.EOL);
		this.mapFollow.put("B", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.EOL);
		this.mapFollow.put("I", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.LLAVE_D);
		this.mapFollow.put("1", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.LLAVE_D);
		this.mapFollow.put("2", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.EOL);
		this.mapFollow.put("D", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.EOL);
		this.mapFollow.put("3", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.EOL);
		this.mapFollow.put("S", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.EOL);
		this.mapFollow.put("M", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.ID);
		this.mapFollow.put("T", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.EOL);
		this.mapFollow.put("X", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.PARENTESIS_D);
		this.auxList.add(Token.COMA);
		this.auxList.add(Token.EOL);
		this.mapFollow.put("R", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.PARENTESIS_D);
		this.auxList.add(Token.COMA);
		this.auxList.add(Token.EOL);
		this.mapFollow.put("N", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.OR);
		this.auxList.add(Token.PARENTESIS_D);
		this.auxList.add(Token.COMA);
		this.auxList.add(Token.EOL);
		this.mapFollow.put("V", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.OR);
		this.auxList.add(Token.PARENTESIS_D);
		this.auxList.add(Token.COMA);
		this.auxList.add(Token.EOL);
		this.mapFollow.put("O", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.ASIGNACIONRESTO);
		this.auxList.add(Token.OR);
		this.auxList.add(Token.PARENTESIS_D);
		this.auxList.add(Token.COMA);
		this.auxList.add(Token.EOL);
		this.mapFollow.put("U", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.ASIGNACIONRESTO);
		this.auxList.add(Token.OR);
		this.auxList.add(Token.PARENTESIS_D);
		this.auxList.add(Token.COMA);
		this.auxList.add(Token.EOL);
		this.mapFollow.put("W", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.RESTO);
		this.auxList.add(Token.ASIGNACIONRESTO);
		this.auxList.add(Token.OR);
		this.auxList.add(Token.PARENTESIS_D);
		this.auxList.add(Token.COMA);
		this.auxList.add(Token.EOL);
		this.mapFollow.put("E", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.RESTO);
		this.auxList.add(Token.ASIGNACIONRESTO);
		this.auxList.add(Token.OR);
		this.auxList.add(Token.PARENTESIS_D);
		this.auxList.add(Token.COMA);
		this.auxList.add(Token.EOL);
		this.mapFollow.put("Y", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.PARENTESIS_D);
		this.mapFollow.put("L", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.PARENTESIS_D);
		this.mapFollow.put("Q", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.EOL);
		this.mapFollow.put("F", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.LLAVE_I);
		this.auxList.add(Token.VAR);
		this.auxList.add(Token.WHILE);
		this.auxList.add(Token.ID);
		this.auxList.add(Token.RETURN);
		this.auxList.add(Token.WRITE);
		this.auxList.add(Token.PROMPT);
		this.auxList.add(Token.LLAVE_D);
		this.mapFollow.put("G", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.ID);
		this.mapFollow.put("H", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.PARENTESIS_D);
		this.mapFollow.put("A", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.PARENTESIS_D);
		this.mapFollow.put("K", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.LLAVE_D);
		this.mapFollow.put("C", auxList);
		
		this.auxList = new ArrayList<>();
		this.auxList.add(Token.LLAVE_D);
		this.mapFollow.put("J", auxList);

	}

	private void concValue() {
		this.currentString = String.valueOf(this.currentString) + this.currentChar;
	}

}
