package Analizador;

import java.util.ArrayList;

import java.util.HashMap;
import java.util.Map;

import Objetos.EntradaAux;
import Objetos.Funcion;
import Objetos.Reader;
import Objetos.Tipo;
import Objetos.Token;
import Objetos.Writter;

/** Comprobar si return = tipo_fun **/
public class AnalizadorSintactico {

	private Map<String, ArrayList<Token>> mapFirst;
	private Map<String, ArrayList<Token>> mapFollow;
	private Token actualToken;
	private Token lastToken;
	private Token lastTokenF;
	private ArrayList<Token> auxList;
	private ArrayList<Token> auxListF;
	private String parse;
	private String tipoF;
	private String args;
	private String n_fun;
	private String file_path;
	private boolean flag_fun;
	private boolean flag_eq;
	private boolean flag_cuerpo;
	private Reader lectura;
	private Funcion funcion;
	private AnalizadorLexico aLex;
	private Writter parseWritter;
	private ErrorControl errControl;
	private char currentChar;
	private String currentString;
	private int currentNumber;
	private TablaSimbolosControl stHandler = new TablaSimbolosControl();
	private EntradaAux entry = new EntradaAux(Tipo.VACIO, 0);

	public AnalizadorSintactico(String ruta) {
		this.file_path = ruta;
		this.parseWritter = new Writter("C:\\Users\\RAYS\\Documents\\Salidas\\parse.txt");

		this.parse = "Descendente ";
		this.args = "";
		this.tipoF = "";
		this.flag_fun = false;
		this.flag_eq = false;
		this.flag_eq = false;
		lectura = new Reader(ruta);
		errControl = new ErrorControl("C:\\Users\\RAYS\\Documents\\Salidas\\errores.txt");
		Writter escritura = new Writter("C:\\Users\\RAYS\\Documents\\Salidas\\token.txt");
		aLex = new AnalizadorLexico(lectura, escritura, stHandler, errControl);
		this.actualToken = aLex.getToken();

		inicializarMaps();
		programa();
		parseWritter.write(parse);

	}

	private void programa() {

		this.stHandler.createTable();
		this.ProcedureZ();
		//this.stHandler.removeTable();
	}

	// REALIZADO
	private void ProcedureZ() {
		if (this.getFirst("P").contains(this.actualToken)) {
			parse += " 1";
			this.ProcedureP();
		} else if (this.actualToken.equals(Token.EOL)) {
			parse += " 2";
			this.compToken(Token.EOL);
			this.ProcedureZ();
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Estructura de programa incorrecta Z",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureP() {
		if (this.getFirst("B").contains(this.actualToken)) {
			parse += " 3";
			this.ProcedureB();
			this.compToken(Token.EOL);
			this.ProcedureZ();
		} else if (this.getFirst("F").contains(this.actualToken)) {
			parse += " 4";
			this.ProcedureF();
			this.compToken(Token.EOL);
			this.ProcedureZ();
		} else if (this.actualToken.equals(Token.EOF)) {
			parse += " 5";
			this.compToken(Token.EOF);
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Estructura de programa incorrecta P",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureB() {
		if (this.actualToken.equals(Token.VAR)) {
			parse += " 6";
			this.compToken(Token.VAR);
			this.ProcedureT();
			this.compToken(Token.EOL);
			this.ProcedureD();
		} else if (this.actualToken.equals(Token.WHILE)) {
			parse += " 7";
			this.compToken(Token.WHILE);
			this.compToken(Token.PARENTESIS_I);
			this.ProcedureR();
			this.compToken(Token.PARENTESIS_D);
			this.compToken(Token.EOL);
			this.ProcedureI();
		} else if (this.getFirst("S").contains(this.actualToken)) {
			parse += " 8";
			this.ProcedureS();
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Estructura de programa incorrecta B",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureI() {
		if (this.getFirst("S").contains(this.actualToken)) {
			parse += " 9";
			this.ProcedureS();
		} else if (this.actualToken.equals(Token.LLAVE_I)) {
			parse += " 10";
			this.compToken(Token.LLAVE_I);
			this.compToken(Token.EOL);
			this.Procedure1();
			this.compToken(Token.LLAVE_D);
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Error en declaracion de FOR I",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void Procedure1() {
		if (this.getFirst("B").contains(this.actualToken)) {
			parse += " 11";
			this.ProcedureB();
			this.compToken(Token.EOL);
			this.Procedure2();
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Error en declaracion de variable 1",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void Procedure2() {
		if (this.getFirst("1").contains(this.actualToken)) {
			parse += " 13";
			this.Procedure1();
		} else if (this.getFollow("2").contains(this.actualToken)) {
			parse += " 14";
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Error en estructura de funcion 2",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureD() {
		if (this.actualToken.equals(Token.COMA)) {
			parse += " 15";
			this.compToken(Token.COMA);
			this.compToken(Token.ID);
			this.ProcedureD();
		} else if (this.actualToken.equals(Token.ASIGNACION)) {
			parse += " 16";
			this.compToken(Token.ASIGNACION);
			this.ProcedureR();
			this.Procedure3();
		} else if (this.getFollow("D").contains(this.actualToken)) {
			parse += " 17";
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Error token no esperado D",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void Procedure3() {
		if (this.actualToken.equals(Token.COMA)) {
			parse += " 18";
			this.compToken(Token.COMA);
			this.compToken(Token.ID);
			this.ProcedureD();
		} else if (this.getFollow("3").contains(this.actualToken)) {
			parse += " 19";
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Error en llamada a funcion 3",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureS() {
		if (this.actualToken.equals(Token.ID)) {
			parse += " 20";
			this.compToken(Token.ID);
			this.ProcedureM();
		} else if (this.actualToken.equals(Token.RETURN)) {
			parse += " 21";
			this.compToken(Token.RETURN);
			this.ProcedureX();
		} else if (this.actualToken.equals(Token.WRITE)) {
			parse += " 22";
			this.compToken(Token.WRITE);
			this.compToken(Token.PARENTESIS_I);
			this.ProcedureR();
			this.compToken(Token.PARENTESIS_D);
		} else if (this.actualToken.equals(Token.PROMPT)) {
			parse += " 23";
			this.compToken(Token.PROMPT);
			this.compToken(Token.PARENTESIS_I);
			this.compToken(Token.ID);
			this.compToken(Token.PARENTESIS_D);
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Error token no esperado S",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureM() {
		if (this.actualToken.equals(Token.ASIGNACION)) {
			parse += " 24";
			this.compToken(Token.ASIGNACION);
			this.ProcedureR();
		} else if (this.actualToken.equals(Token.MAYOR)) {
			parse += " 25";
			this.compToken(Token.MAYOR);
			this.ProcedureR();
		} else if (this.actualToken.equals(Token.PARENTESIS_I)) {
			parse += " 26";
			this.compToken(Token.PARENTESIS_I);
			this.ProcedureL();
			this.compToken(Token.PARENTESIS_D);
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Error en declaracion de funcion M",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureT() {
		if (this.actualToken.equals(Token.INT)) {
			parse += " 27";
			this.compToken(Token.INT);
		} else if (this.actualToken.equals(Token.BOOL)) {
			parse += " 28";
			this.compToken(Token.BOOL);
		} else if (this.actualToken.equals(Token.CHARS)) {
			parse += " 29";
			this.compToken(Token.CHARS);
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Error en sentencia 'return' T",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureX() {
		if (this.getFirst("R").contains(this.actualToken)) {
			parse += " 30";
			this.ProcedureR();
		} else if (this.getFollow("X").contains(this.actualToken)) {
			parse += " 31";
		} else {
			this.errControl
					.write(String.format("Linea %d: Analizador Sintactico - Error en la declaracion de argumentos X",
							aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureR() {
		if (this.getFirst("V").contains(this.actualToken)) {
			parse += " 32";
			this.ProcedureV();
			this.ProcedureN();
		} else {
			this.errControl
					.write(String.format("Linea %d: Analizador Sintactico - Error en la declaracion de argumentos R",
							aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureN() {
		if (this.actualToken.equals(Token.OR)) {
			parse += " 33";
			this.compToken(Token.OR);
			this.ProcedureV();
			this.ProcedureN();
		} else if (this.getFollow("N").contains(this.actualToken)) {
			parse += " 34";

		} else {
			this.errControl.write(String.format("Linea %d:  Analizador Semantico - Argumentos incorrectos N",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureV() {
		if (this.getFirst("U").contains(this.actualToken)) {
			parse += " 35";
			this.ProcedureU();
			this.ProcedureO();
		} else {
			this.errControl
					.write(String.format("Linea %d: Analizador Sintactico - Error en la declaracion de argumentos V",
							aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureO() {
		if (this.actualToken.equals(Token.ASIGNACIONRESTO)) {
			parse += " 36";
			this.compToken(Token.ASIGNACIONRESTO);
			this.ProcedureU();
		} else if (this.getFollow("O").contains(this.actualToken)) {
			parse += " 37";
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Error token no esperado O",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureU() {
		if (this.getFirst("E").contains(this.actualToken)) {
			parse += " 38";
			this.ProcedureE();
			this.ProcedureW();
		} else {
			this.errControl
					.write(String.format("Linea %d: Analizador Sintactico - Error en la declaracion de argumentos U",
							aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureW() {
		if (this.actualToken.equals(Token.RESTO)) {
			parse += " 39";
			this.compToken(Token.RESTO);
			this.ProcedureU();
		} else if (this.getFollow("W").contains(this.actualToken)) {
			parse += " 40";
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Error token no esperado W",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureE() {
		if (this.actualToken.equals(Token.ID)) {
			parse += " 41";
			this.compToken(Token.ID);
			this.ProcedureY();
		} else if (this.actualToken.equals(Token.PARENTESIS_I)) {
			parse += " 42";
			this.compToken(Token.PARENTESIS_I);
			this.ProcedureR();
			this.compToken(Token.PARENTESIS_D);
		} else if (this.actualToken.equals(Token.INT)) {
			parse += " 43";
			this.compToken(Token.INT);
		} else if (this.actualToken.equals(Token.CAD)) {
			parse += " 44";
			this.compToken(Token.CAD);
		} else if (this.actualToken.equals(Token.TRUE)) {
			parse += " 45";
			this.compToken(Token.TRUE);
		} else if (this.actualToken.equals(Token.FALSE)) {
			parse += " 46";
			this.compToken(Token.FALSE);
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Error token no esperado E",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureY() {
		if (this.actualToken.equals(Token.PARENTESIS_I)) {
			parse += " 47";
			this.compToken(Token.PARENTESIS_I);
			this.ProcedureL();
			this.compToken(Token.PARENTESIS_D);
		} else if (this.getFollow("Y").contains(this.actualToken)) {
			parse += " 48";
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Error token no esperado Y",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureL() {
		if (this.getFirst("R").contains(this.actualToken)) {
			parse += " 49";
			this.ProcedureR();
			this.ProcedureQ();
		} else if (this.getFollow("L").contains(this.actualToken)) {
			parse += " 50";
		} else {
			this.errControl
					.write(String.format("Linea %d: Analizador Sintactico - Error en la declaracion de argumentos L",
							aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureQ() {
		if (this.actualToken.equals(Token.COMA)) {
			parse += " 51";
			this.compToken(Token.COMA);
			this.ProcedureR();
			this.ProcedureQ();
		} else if (this.getFollow("Q").contains(this.actualToken)) {
			parse += " 52";
		} else {
			this.errControl
					.write(String.format("Linea %d: Analizador Sintactico - Error en la declaracion de argumentos Q",
							aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureF() {
		if (this.actualToken.equals(Token.FUNCTION)) {
			parse += " 53";
			this.compToken(Token.FUNCTION);
			this.ProcedureH();
			this.compToken(Token.ID);
			this.compToken(Token.PARENTESIS_I);
			this.ProcedureA();
			this.compToken(Token.PARENTESIS_D);
			this.compToken(Token.EOL);
			this.ProcedureG();
			this.compToken(Token.LLAVE_I);
			this.compToken(Token.EOL);
			this.ProcedureC();
			this.compToken(Token.LLAVE_D);
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Error token no esperado F",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureG() {
		if (this.actualToken.equals(Token.EOL)) {
			parse += " 54";
			this.compToken(Token.EOL);
			this.ProcedureG();
		} else if (this.getFollow("G").contains(this.actualToken)) {
			parse += " 55";
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Error en declaracion FOR G",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureH() {
		if (this.getFirst("T").contains(this.actualToken)) {
			parse += " 56";
			this.ProcedureT();
		} else if (this.getFollow("H").contains(this.actualToken)) {
			parse += " 57";
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Error en declaracion FOR H",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureA() {
		if (this.getFirst("T").contains(this.actualToken)) {
			parse += " 58";
			this.ProcedureT();
			this.compToken(Token.ID);
			this.ProcedureK();
		} else if (this.getFollow("A").contains(this.actualToken)) {
			parse += " 59";
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Error en declaracion FOR A",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureK() {
		if (this.actualToken.equals(Token.COMA)) {
			parse += " 60";
			this.compToken(Token.COMA);
			this.ProcedureV();
			this.compToken(Token.ID);
			this.ProcedureK();
		} else if (this.getFollow("K").contains(this.actualToken)) {
			parse += " 61";
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Error en declaracion FOR K",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureC() {
		if (this.getFirst("B").contains(this.actualToken)) {
			parse += " 62";
			this.ProcedureB();
			this.compToken(Token.EOL);
			this.ProcedureG();
			this.ProcedureJ();
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Error en declaracion FOR C",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	// REALIZADO
	private void ProcedureJ() {
		if (this.getFirst("C").contains(this.actualToken)) {
			parse += " 63";
			this.ProcedureC();
		} else if (this.getFollow("J").contains(this.actualToken)) {
			parse += " 64";
		} else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico - Error en declaracion FOR J",
					aLex.getFileReader().getCurrentLine()));
		}
	}

	private void compToken(Token token) {
		if (token.equals(Token.EOF)) {
			
		} else {
		if (token.equals(Token.EOL)) {
			while (!this.actualToken.equals(Token.EOL) && !this.actualToken.equals(Token.EOF)) {
				this.nextToken();
			}
		}
		if (this.actualToken.equals(token)) {
			if (actualToken.equals(Token.ID) || actualToken.equals(Token.NUM)) {
				this.lastToken = this.actualToken;

			}
			this.nextToken();
		}

		else {
			this.errControl.write(String.format("Linea %d: Analizador Sintactico, Error token no esperado",
					aLex.getFileReader().getCurrentLine()));
			nextToken();
			compToken(actualToken);
		}}
	}

	private void nextToken() {
		this.actualToken = this.aLex.getToken();
		if (this.actualToken == null) {
			this.nextToken();
		}
	}

	private ArrayList<Token> getFirst(String a) {
		ArrayList<Token> list = new ArrayList<Token>();
		list = this.mapFirst.get(a);
		return list;
	}

	private ArrayList<Token> getFollow(String a) {
		ArrayList<Token> list = new ArrayList<Token>();
		list = this.mapFollow.get(a);
		return list;
	}

	// INICIALIZA MAPS
	private void inicializarMaps() {
		this.mapFirst = new HashMap<String, ArrayList<Token>>();

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.VAR);
		this.auxList.add(Token.WHILE);
		this.auxList.add(Token.ID);
		this.auxList.add(Token.RETURN);
		this.auxList.add(Token.WRITE);
		this.auxList.add(Token.PROMPT);
		this.auxList.add(Token.EOL);
		this.auxList.add(Token.FUNCTION);
		this.auxList.add(Token.EOF);
		this.mapFirst.put("Z", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.VAR);
		this.auxList.add(Token.WHILE);
		this.auxList.add(Token.ID);
		this.auxList.add(Token.RETURN);
		this.auxList.add(Token.WRITE);
		this.auxList.add(Token.PROMPT);
		this.auxList.add(Token.FUNCTION);
		this.auxList.add(Token.EOF);
		this.mapFirst.put("P", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.VAR);
		this.auxList.add(Token.WHILE);
		this.auxList.add(Token.ID);
		this.auxList.add(Token.RETURN);
		this.auxList.add(Token.WRITE);
		this.auxList.add(Token.PROMPT);
		this.mapFirst.put("B", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.ID);
		this.auxList.add(Token.RETURN);
		this.auxList.add(Token.WRITE);
		this.auxList.add(Token.PROMPT);
		this.auxList.add(Token.LLAVE_I);
		this.mapFirst.put("I", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.VAR);
		this.auxList.add(Token.WHILE);
		this.auxList.add(Token.ID);
		this.auxList.add(Token.RETURN);
		this.auxList.add(Token.WRITE);
		this.auxList.add(Token.PROMPT);
		this.mapFirst.put("1", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.VAR);
		this.auxList.add(Token.WHILE);
		this.auxList.add(Token.ID);
		this.auxList.add(Token.RETURN);
		this.auxList.add(Token.WRITE);
		this.auxList.add(Token.PROMPT);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("2", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.COMA);
		this.auxList.add(Token.ASIGNACION);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("D", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.COMA);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("3", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.ID);
		this.auxList.add(Token.RETURN);
		this.auxList.add(Token.WRITE);
		this.auxList.add(Token.PROMPT);
		this.mapFirst.put("S", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.ASIGNACION);
		this.auxList.add(Token.MAYOR);
		this.auxList.add(Token.PARENTESIS_I);
		this.mapFirst.put("M", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.INT);
		this.auxList.add(Token.BOOL);
		this.auxList.add(Token.CHARS);
		this.mapFirst.put("T", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.ID);
		this.auxList.add(Token.PARENTESIS_I);
		this.auxList.add(Token.INT);
		this.auxList.add(Token.CAD);
		this.auxList.add(Token.TRUE);
		this.auxList.add(Token.FALSE);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("X", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.ID);
		this.auxList.add(Token.PARENTESIS_I);
		this.auxList.add(Token.INT);
		this.auxList.add(Token.CAD);
		this.auxList.add(Token.TRUE);
		this.auxList.add(Token.FALSE);
		this.mapFirst.put("R", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.OR);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("N", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.ID);
		this.auxList.add(Token.PARENTESIS_I);
		this.auxList.add(Token.INT);
		this.auxList.add(Token.CAD);
		this.auxList.add(Token.TRUE);
		this.auxList.add(Token.FALSE);
		this.mapFirst.put("V", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.ASIGNACIONRESTO);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("O", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.ID);
		this.auxList.add(Token.PARENTESIS_I);
		this.auxList.add(Token.INT);
		this.auxList.add(Token.CAD);
		this.auxList.add(Token.TRUE);
		this.auxList.add(Token.FALSE);
		this.mapFirst.put("U", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.RESTO);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("W", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.ID);
		this.auxList.add(Token.PARENTESIS_I);
		this.auxList.add(Token.INT);
		this.auxList.add(Token.CAD);
		this.auxList.add(Token.TRUE);
		this.auxList.add(Token.FALSE);
		this.mapFirst.put("E", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.PARENTESIS_I);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("Y", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.ID);
		this.auxList.add(Token.PARENTESIS_I);
		this.auxList.add(Token.INT);
		this.auxList.add(Token.CAD);
		this.auxList.add(Token.TRUE);
		this.auxList.add(Token.FALSE);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("L", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.COMA);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("Q", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.FUNCTION);
		this.mapFirst.put("F", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.EOL);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("G", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.INT);
		this.auxList.add(Token.BOOL);
		this.auxList.add(Token.CHARS);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("H", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.INT);
		this.auxList.add(Token.BOOL);
		this.auxList.add(Token.CHARS);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("A", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.COMA);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("K", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.VAR);
		this.auxList.add(Token.WHILE);
		this.auxList.add(Token.ID);
		this.auxList.add(Token.RETURN);
		this.auxList.add(Token.WRITE);
		this.auxList.add(Token.PROMPT);
		this.mapFirst.put("C", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.VAR);
		this.auxList.add(Token.WHILE);
		this.auxList.add(Token.ID);
		this.auxList.add(Token.RETURN);
		this.auxList.add(Token.WRITE);
		this.auxList.add(Token.PROMPT);
		this.auxList.add(Token.LAMBDA);
		this.mapFirst.put("J", auxList);

		
		// FOLLOWS
		this.mapFollow = new HashMap<String, ArrayList<Token>>();

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.NULL);
		this.mapFollow.put("Z", auxList);
		
		this.auxList = new ArrayList<>();
		this.auxList.add(Token.NULL);
		this.mapFollow.put("P", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.EOL);
		this.mapFollow.put("B", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.EOL);
		this.mapFollow.put("I", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.LLAVE_D);
		this.mapFollow.put("1", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.LLAVE_D);
		this.mapFollow.put("2", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.EOL);
		this.mapFollow.put("D", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.EOL);
		this.mapFollow.put("3", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.EOL);
		this.mapFollow.put("S", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.EOL);
		this.mapFollow.put("M", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.ID);
		this.mapFollow.put("T", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.EOL);
		this.mapFollow.put("X", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.PARENTESIS_D);
		this.auxList.add(Token.COMA);
		this.auxList.add(Token.EOL);
		this.mapFollow.put("R", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.PARENTESIS_D);
		this.auxList.add(Token.COMA);
		this.auxList.add(Token.EOL);
		this.mapFollow.put("N", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.OR);
		this.auxList.add(Token.PARENTESIS_D);
		this.auxList.add(Token.COMA);
		this.auxList.add(Token.EOL);
		this.mapFollow.put("V", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.OR);
		this.auxList.add(Token.PARENTESIS_D);
		this.auxList.add(Token.COMA);
		this.auxList.add(Token.EOL);
		this.mapFollow.put("O", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.ASIGNACIONRESTO);
		this.auxList.add(Token.OR);
		this.auxList.add(Token.PARENTESIS_D);
		this.auxList.add(Token.COMA);
		this.auxList.add(Token.EOL);
		this.mapFollow.put("U", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.ASIGNACIONRESTO);
		this.auxList.add(Token.OR);
		this.auxList.add(Token.PARENTESIS_D);
		this.auxList.add(Token.COMA);
		this.auxList.add(Token.EOL);
		this.mapFollow.put("W", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.RESTO);
		this.auxList.add(Token.ASIGNACIONRESTO);
		this.auxList.add(Token.OR);
		this.auxList.add(Token.PARENTESIS_D);
		this.auxList.add(Token.COMA);
		this.auxList.add(Token.EOL);
		this.mapFollow.put("E", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.RESTO);
		this.auxList.add(Token.ASIGNACIONRESTO);
		this.auxList.add(Token.OR);
		this.auxList.add(Token.PARENTESIS_D);
		this.auxList.add(Token.COMA);
		this.auxList.add(Token.EOL);
		this.mapFollow.put("Y", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.PARENTESIS_D);
		this.mapFollow.put("L", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.PARENTESIS_D);
		this.mapFollow.put("Q", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.EOL);
		this.mapFollow.put("F", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.LLAVE_I);
		this.auxList.add(Token.VAR);
		this.auxList.add(Token.WHILE);
		this.auxList.add(Token.ID);
		this.auxList.add(Token.RETURN);
		this.auxList.add(Token.WRITE);
		this.auxList.add(Token.PROMPT);
		this.auxList.add(Token.LLAVE_D);
		this.mapFollow.put("G", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.ID);
		this.mapFollow.put("H", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.PARENTESIS_D);
		this.mapFollow.put("A", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.PARENTESIS_D);
		this.mapFollow.put("K", auxList);

		this.auxList = new ArrayList<>();
		this.auxList.add(Token.LLAVE_D);
		this.mapFollow.put("C", auxList);
		
		this.auxList = new ArrayList<>();
		this.auxList.add(Token.LLAVE_D);
		this.mapFollow.put("J", auxList);

	}

	private void concValue() {
		this.currentString = String.valueOf(this.currentString) + this.currentChar;
	}

}
